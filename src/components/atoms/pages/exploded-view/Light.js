/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {useRef} from 'react'
import {Box, useGLTF, Html, useScroll, Image} from '@react-three/drei'
import {useFrame} from "@react-three/fiber";
import * as THREE from "three";
import {PointLightHelper} from "three";
import Line from "./Line";
import label from '../../../../assets/exploded-view/label.png'

const caseMaterial = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color('#ffffff').convertSRGBToLinear(),
  roughness: 0,
  clearcoat: 1,
  clearcoatRoughness: 0
})

const clearPlastic = new THREE.MeshPhysicalMaterial({
  roughness: 0.07,
  transmission: 1,
  thickness: 0
})

const ledMaterial = new THREE.MeshPhysicalMaterial({
  roughness: 0,
  emissive: new THREE.Color('#99f6ff').convertSRGBToLinear(),
  emissiveIntensity: 0.25,
  metalness: 0.7,
  toneMapped: false
})

const curcuitMaterial = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color('#416042').convertSRGBToLinear(),
  roughness: 0.7
})

const batteryMaterial = new THREE.MeshStandardMaterial({
  color: new THREE.Color('#ffffff').convertSRGBToLinear(),
  metalness: 1,   // between 0 and 1
  roughness: 0.01, // between 0 and 1
})

export function Model(props) {
  const {nodes, materials} = useGLTF('/exploded-view/light.glb')
  const group = useRef(null)
  const inner = useRef(null)
  const battery = useRef(null)
  const circuitBoard = useRef(null)
  const led = useRef(null)
  const cap = useRef(null)
  const casing = useRef(null)
  const light = useRef()
  const label1 = useRef()
  const label1Img = useRef()
  const label1Line = useRef()
  const label2 = useRef()
  const label2Img = useRef()
  const label2Line = useRef()
  const label3 = useRef()
  const label3Img = useRef()
  const label3Line = useRef()
  const label4 = useRef()
  const label4Img = useRef()
  const label4Line = useRef()
  // useHelper(light, PointLightHelper, 0.01)

  const data = useScroll()
  useFrame(() => {
    const a = data.range(0, 1/7)
    const b = data.range(1/7, 1/7)
    const c = data.range(2/7, 1/7)
    const d = data.range(3/7, 1/7)
    const e = data.range(4/7, 2/7)

    const e1 = data.range(4/7, 2/7/12)
    const e2 = data.range((4/7) + (2/7/12), 2/7/12)
    const e3 = data.range((4/7) + (2/7/12*2), 2/7/12)
    const e4 = data.range((4/7) + (2/7/12*3), 2/7/12)

    const e5 = data.range((4/7) + (2/7/12*8), 2/7/12)
    const e6 = data.range((4/7) + (2/7/12*9), 2/7/12)
    const e7 = data.range((4/7) + (2/7/12*10), 2/7/12)
    const e8 = data.range((4/7) + (2/7/12*11), 2/7/12)

    const f = data.range(6/7, 1/7)
    if (a < 1) {
      group.current.position.y = THREE.MathUtils.lerp(5, 0, a)
      group.current.rotation.y = THREE.MathUtils.lerp(-Math.PI * 2, Math.PI / 2, a)
    } else if (b < 1) {
      inner.current.rotation.x = THREE.MathUtils.lerp(0, -Math.PI / 2, b)
    } else if (c < 1) {
      casing.current.position.y = THREE.MathUtils.lerp(0, -0.04, c)
      battery.current.position.y = THREE.MathUtils.lerp(0, -0.005, c)
      circuitBoard.current.position.y = THREE.MathUtils.lerp(0, -0.001, c)
      led.current.position.y = THREE.MathUtils.lerp(0, 0.002, c)
      light.current.position.y = THREE.MathUtils.lerp(0.035, 0.038, c)
      cap.current.position.y = THREE.MathUtils.lerp(0, 0.02, c)
    } else if (d < 1) {
      inner.current.rotation.z = THREE.MathUtils.lerp(0, -Math.PI / 4, d)
      inner.current.rotation.x = THREE.MathUtils.lerp(-Math.PI / 2, -Math.PI / 3, d)
      label1Line.current.material.opacity = 0
      label1Img.current.material.opacity = 0
    } else if (e < 1) {

      if(e4 < 1) {
        label1Line.current.material.opacity = THREE.MathUtils.lerp(0, 1, e1)
        label1Img.current.material.opacity = THREE.MathUtils.lerp(0, 1, e1)

        label2Line.current.material.opacity = THREE.MathUtils.lerp(0, 1, e2)
        label2Img.current.material.opacity = THREE.MathUtils.lerp(0, 1, e2)

        label3Line.current.material.opacity = THREE.MathUtils.lerp(0, 1, e3)
        label3Img.current.material.opacity = THREE.MathUtils.lerp(0, 1, e3)

        label4Line.current.material.opacity = THREE.MathUtils.lerp(0, 1, e4)
        label4Img.current.material.opacity = THREE.MathUtils.lerp(0, 1, e4)
      } else {
        label1Line.current.material.opacity = THREE.MathUtils.lerp(1, 0, e5)
        label1Img.current.material.opacity = THREE.MathUtils.lerp(1, 0, e5)

        label2Line.current.material.opacity = THREE.MathUtils.lerp(1, 0, e6)
        label2Img.current.material.opacity = THREE.MathUtils.lerp(1, 0, e6)

        label3Line.current.material.opacity = THREE.MathUtils.lerp(1, 0, e7)
        label3Img.current.material.opacity = THREE.MathUtils.lerp(1, 0, e7)

        label4Line.current.material.opacity = THREE.MathUtils.lerp(1, 0, e8)
        label4Img.current.material.opacity = THREE.MathUtils.lerp(1, 0, e8)
      }

    } else if (f < 1) {
      label4Line.current.material.opacity = 0
      label4Img.current.material.opacity = 0
      casing.current.position.y = THREE.MathUtils.lerp(-0.04, 0, f)
      battery.current.position.y = THREE.MathUtils.lerp(-0.005, 0, f)
      circuitBoard.current.position.y = THREE.MathUtils.lerp(-0.001, 0, f)
      led.current.position.y = THREE.MathUtils.lerp(0.002, 0, f)
      light.current.position.y = THREE.MathUtils.lerp(0.038, 0.035, f)
      cap.current.position.y = THREE.MathUtils.lerp(0.02, 0, f)
    }
  })

  return (
    <>
      <group ref={group}>
        <group ref={inner}>
          <group {...props} dispose={null} rotation={[0, 0, Math.PI]}>
            <mesh ref={battery} geometry={nodes.battery.geometry} material={batteryMaterial} scale={0.001} />
            <mesh receiveShadow ref={circuitBoard} geometry={nodes['circuit-board'].geometry} material={curcuitMaterial}
                  scale={0.001} />
            <mesh castShadow ref={led} geometry={nodes.led.geometry} material={ledMaterial} scale={0.001} />
            <pointLight castShadow ref={light} position={[0, 0.035, 0]} color="white" intensity={0.5} />
            <mesh ref={cap} geometry={nodes.cap.geometry} material={clearPlastic} scale={0.001} />
            <mesh ref={casing} geometry={nodes['outer-case'].geometry} material={caseMaterial} scale={0.001} />
          </group>
        </group>
      </group>

      <group ref={label1}>
        <Line ref={label1Line} start={new THREE.Vector3(-1.5, -0.25, 0)} end={new THREE.Vector3(-1.25, 0.5, -1.25)} />
        <Image position={[-1.5, -0.5, 0]} ref={label1Img} url={label} transparent opacity={0} scale={[1.5, 2 / 5 * 1.5, 1]} />
      </group>

      <group ref={label2}>
        <Line ref={label2Line} start={new THREE.Vector3(0.5, 1.15, 0)} end={new THREE.Vector3(0.1, 0, 0.1)} />
        <Image position={[0.5, 1.4, 0]} ref={label2Img} url={label} transparent opacity={0} scale={[1.5, 2 / 5 * 1.5, 1]} />
      </group>

      <group ref={label3}>
        <Line ref={label3Line} start={new THREE.Vector3(1.7, 0.2, 0)} end={new THREE.Vector3(0.75, -0.25, 1.25)} />
        <Image position={[1.7, 0.5, 0]} ref={label3Img} url={label} transparent opacity={0} scale={[1.5, 2 / 5 * 1.5, 1]} />
      </group>

      <group ref={label4}>
        <Line ref={label4Line} start={new THREE.Vector3(0.75, -1.5, 0)} end={new THREE.Vector3(1, -0.5, 1)} />
        <Image position={[0, -1.5, 0]} ref={label4Img} url={label} transparent opacity={0} scale={[1.5, 2 / 5 * 1.5, 1]} />
      </group>


    </>
  )
}

useGLTF.preload('/exploded-view/light.glb')
