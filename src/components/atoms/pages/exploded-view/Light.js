/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {useRef} from 'react'
import {useGLTF, useHelper, useScroll} from '@react-three/drei'
import {useFrame} from "@react-three/fiber";
import * as THREE from "three";
import {PointLightHelper} from "three";

const caseMaterial = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color('#ffffff').convertSRGBToLinear(),
  roughness: 0,
  clearcoat: 1,
  clearcoatRoughness: 0
})

const clearPlastic = new THREE.MeshPhysicalMaterial({
  roughness: 0.07,
  transmission: 1,
  thickness: 0
})

const ledMaterial = new THREE.MeshPhysicalMaterial({
  roughness: 0,
  emissive: new THREE.Color('#99f6ff').convertSRGBToLinear(),
  emissiveIntensity: 0.25,
  metalness: 0.7,
  toneMapped: false
})

const curcuitMaterial = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color('#416042').convertSRGBToLinear(),
    roughness: 0.7
  })

const batteryMaterial = new THREE.MeshStandardMaterial({
  color: new THREE.Color('#ffffff').convertSRGBToLinear(),
  metalness: 1,   // between 0 and 1
  roughness: 0.01, // between 0 and 1
})

export function Model(props) {
  const {nodes, materials} = useGLTF('/exploded-view/light.glb')
  const group = useRef(null)
  const inner = useRef(null)
  const battery = useRef(null)
  const circuitBoard = useRef(null)
  const led = useRef(null)
  const cap = useRef(null)
  const casing = useRef(null)
  const light = useRef()
  // useHelper(light, PointLightHelper, 0.01)

  const data = useScroll()
  useFrame(() => {
    const a = data.range(0, 0.2)
    const b = data.range(0.2, 0.2)
    const c = data.range(0.4, 0.2)
    const d = data.range(0.6, 0.2)
    const e = data.range(0.8, 0.2)
    if (a < 1) {
      group.current.position.y = THREE.MathUtils.lerp(5, 0, a)
      group.current.rotation.y = THREE.MathUtils.lerp(-Math.PI * 2, Math.PI / 2, a)
    } else if (b < 1) {
      inner.current.rotation.x = THREE.MathUtils.lerp(0, -Math.PI / 2, b)
    } else if (c < 1) {
      casing.current.position.y = THREE.MathUtils.lerp(0, -0.04, c)
      battery.current.position.y = THREE.MathUtils.lerp(0, -0.005, c)
      circuitBoard.current.position.y = THREE.MathUtils.lerp(0, -0.001, c)
      led.current.position.y = THREE.MathUtils.lerp(0, 0.002, c)
      light.current.position.y = THREE.MathUtils.lerp(0.035, 0.038, c)
      cap.current.position.y = THREE.MathUtils.lerp(0, 0.02, c)
    } else if (d < 1) {
      inner.current.rotation.z = THREE.MathUtils.lerp(0, -Math.PI / 4, d)
      inner.current.rotation.x = THREE.MathUtils.lerp(-Math.PI / 2, -Math.PI / 3, d)
    } else if (e < 1) {
      casing.current.position.y = THREE.MathUtils.lerp(-0.04, 0, e)
      battery.current.position.y = THREE.MathUtils.lerp(-0.005, 0, e)
      circuitBoard.current.position.y = THREE.MathUtils.lerp(-0.001, 0, e)
      led.current.position.y = THREE.MathUtils.lerp(0.002, 0, e)
      light.current.position.y = THREE.MathUtils.lerp(0.038, 0.035, e)
      cap.current.position.y = THREE.MathUtils.lerp(0.02, 0, e)
    }
  })

  return (
    <group ref={group}>
      <group ref={inner}>
        <group {...props} dispose={null} rotation={[0, 0, Math.PI]}>
          <mesh ref={battery} geometry={nodes.battery.geometry} material={batteryMaterial} scale={0.001} />
          <mesh receiveShadow ref={circuitBoard} geometry={nodes['circuit-board'].geometry} material={curcuitMaterial}
                scale={0.001} />
          <mesh castShadow ref={led} geometry={nodes.led.geometry} material={ledMaterial} scale={0.001} />
          <pointLight castShadow ref={light} position={[0,0.035,0]} color="white" intensity={0.5} />
          <mesh ref={cap} geometry={nodes.cap.geometry} material={clearPlastic} scale={0.001} />
          <mesh ref={casing} geometry={nodes['outer-case'].geometry} material={caseMaterial} scale={0.001} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/exploded-view/light.glb')
